# Load Balancer Configuration for Orchestry Controller Cluster
# Routes traffic to the active leader controller with automatic failover

# Upstream for read operations - can distribute load to all healthy nodes
upstream controller_cluster_read {
    server controller-1:8001 max_fails=2 fail_timeout=10s;
    server controller-2:8002 max_fails=2 fail_timeout=10s;
    server controller-3:8003 max_fails=2 fail_timeout=10s;
}

# Upstream for write operations - tries all controllers until it finds the leader
upstream controller_cluster_write {
    # All controllers at same priority - nginx will try them in order until one succeeds
    # Non-leader controllers return 503, causing nginx to try the next one
    server controller-1:8001 max_fails=1 fail_timeout=3s;
    server controller-2:8002 max_fails=1 fail_timeout=3s;
    server controller-3:8003 max_fails=1 fail_timeout=3s;
}

# Map to determine if a request needs to go to the leader
map $request_method $needs_leader {
    default "no";
    POST "yes";
    PUT "yes";
    PATCH "yes";
    DELETE "yes";
}

# Map for read-only endpoints that can go to any healthy node
map $uri $is_read_only {
    default "no";
    ~^/health$ "yes";
    ~^/cluster/health$ "yes";
    ~^/cluster/status$ "yes";
    ~^/cluster/leader$ "yes";
    ~^/metrics$ "yes";
    ~^/events$ "yes";
    ~^/apps/.*/status$ "yes";
}

server {
    listen 80;
    server_name _;
    
    # Health check endpoint for the load balancer itself
    location /lb-health {
        access_log off;
        return 200 "Orchestry Controller Load Balancer OK\n";
        add_header Content-Type text/plain;
    }
    
    # Controller cluster health check that shows all nodes
    location /cluster-health {
        access_log off;
        
        # Route to controller cluster with automatic failover
        proxy_pass http://controller_cluster_read/cluster/health;
        proxy_connect_timeout 2s;
        proxy_read_timeout 2s;
        
        add_header X-Load-Balancer "nginx-cluster-health" always;
    }
    
    # Read-only endpoints - can distribute load to all healthy nodes
    location ~ ^/(health|cluster/health|cluster/status|cluster/leader|metrics|events|apps/.*/status|apps/.*/logs|apps$)$ {
        # Set proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
        
        # Route to any healthy controller for read operations
        proxy_pass http://controller_cluster_read;
        
        # Next upstream conditions for automatic failover
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 10s;
        
        # Add headers to show load balancing
        add_header X-Controller-Mode "read-distributed" always;
        add_header X-Load-Balancer "nginx-read" always;
    }
    
    # Write operations - must go to leader only
    location / {
        # Set proxy headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Route to leader controller with optimized failover
        proxy_pass http://controller_cluster_write;
        
        # Aggressive failover for leader election - try all controllers quickly
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 10s;
        
        # Reduced timeouts for faster leader detection
        proxy_connect_timeout 2s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
        
        # Add headers to show leader routing
        add_header X-Controller-Mode "leader-only" always;
        add_header X-Load-Balancer "nginx-leader" always;
    }
    
    # WebSocket support for real-time features (if needed)
    location /ws {
        proxy_pass http://controller_cluster_write;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket timeouts
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
    }
    
    # Error pages
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        return 503 '{"error": "Orchestry Controller Cluster Unavailable", "timestamp": "$time_iso8601", "status": 503}';
        add_header Content-Type application/json always;
    }
    
    # Logging
    access_log /var/log/nginx/controller_access.log;
    error_log /var/log/nginx/controller_error.log warn;
}


